// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

// struct PacketHeader, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct PacketHeader(pub [u8; 8]);
impl Default for PacketHeader {
    fn default() -> Self {
        Self([0; 8])
    }
}
impl core::fmt::Debug for PacketHeader {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PacketHeader")
            .field("track_id", &self.track_id())
            .field("size", &self.size())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PacketHeader {}
impl<'a> flatbuffers::Follow<'a> for PacketHeader {
    type Inner = &'a PacketHeader;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a PacketHeader>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a PacketHeader {
    type Inner = &'a PacketHeader;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<PacketHeader>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for PacketHeader {
    type Output = PacketHeader;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const PacketHeader as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(4)
    }
}

impl<'a> flatbuffers::Verifiable for PacketHeader {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> PacketHeader {
    #[allow(clippy::too_many_arguments)]
    pub fn new(track_id: i32, size: i32) -> Self {
        let mut s = Self([0; 8]);
        s.set_track_id(track_id);
        s.set_size(size);
        s
    }

    pub fn track_id(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_track_id(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn size(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_size(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum FileDataDefinitionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FileDataDefinition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileDataDefinition<'a> {
    type Inner = FileDataDefinition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FileDataDefinition<'a> {
    pub const VT_BYTE_OFFSET: flatbuffers::VOffsetT = 4;
    pub const VT_PACKET_HEADER: flatbuffers::VOffsetT = 6;
    pub const VT_ELEMENTS_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_START_T: flatbuffers::VOffsetT = 10;
    pub const VT_END_T: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileDataDefinition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FileDataDefinitionArgs<'args>,
    ) -> flatbuffers::WIPOffset<FileDataDefinition<'bldr>> {
        let mut builder = FileDataDefinitionBuilder::new(_fbb);
        builder.add_end_t(args.end_t);
        builder.add_start_t(args.start_t);
        builder.add_elements_count(args.elements_count);
        builder.add_byte_offset(args.byte_offset);
        if let Some(x) = args.packet_header {
            builder.add_packet_header(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn byte_offset(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(FileDataDefinition::VT_BYTE_OFFSET, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn packet_header(&self) -> Option<&'a PacketHeader> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PacketHeader>(FileDataDefinition::VT_PACKET_HEADER, None)
        }
    }
    #[inline]
    pub fn elements_count(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(FileDataDefinition::VT_ELEMENTS_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn start_t(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(FileDataDefinition::VT_START_T, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn end_t(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(FileDataDefinition::VT_END_T, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FileDataDefinition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("byte_offset", Self::VT_BYTE_OFFSET, false)?
            .visit_field::<PacketHeader>("packet_header", Self::VT_PACKET_HEADER, false)?
            .visit_field::<i64>("elements_count", Self::VT_ELEMENTS_COUNT, false)?
            .visit_field::<i64>("start_t", Self::VT_START_T, false)?
            .visit_field::<i64>("end_t", Self::VT_END_T, false)?
            .finish();
        Ok(())
    }
}
pub struct FileDataDefinitionArgs<'a> {
    pub byte_offset: i64,
    pub packet_header: Option<&'a PacketHeader>,
    pub elements_count: i64,
    pub start_t: i64,
    pub end_t: i64,
}
impl<'a> Default for FileDataDefinitionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileDataDefinitionArgs {
            byte_offset: 0,
            packet_header: None,
            elements_count: 0,
            start_t: 0,
            end_t: 0,
        }
    }
}

pub struct FileDataDefinitionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FileDataDefinitionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_byte_offset(&mut self, byte_offset: i64) {
        self.fbb_
            .push_slot::<i64>(FileDataDefinition::VT_BYTE_OFFSET, byte_offset, 0);
    }
    #[inline]
    pub fn add_packet_header(&mut self, packet_header: &PacketHeader) {
        self.fbb_
            .push_slot_always::<&PacketHeader>(FileDataDefinition::VT_PACKET_HEADER, packet_header);
    }
    #[inline]
    pub fn add_elements_count(&mut self, elements_count: i64) {
        self.fbb_
            .push_slot::<i64>(FileDataDefinition::VT_ELEMENTS_COUNT, elements_count, 0);
    }
    #[inline]
    pub fn add_start_t(&mut self, start_t: i64) {
        self.fbb_
            .push_slot::<i64>(FileDataDefinition::VT_START_T, start_t, 0);
    }
    #[inline]
    pub fn add_end_t(&mut self, end_t: i64) {
        self.fbb_
            .push_slot::<i64>(FileDataDefinition::VT_END_T, end_t, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FileDataDefinitionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FileDataDefinitionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FileDataDefinition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FileDataDefinition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FileDataDefinition");
        ds.field("byte_offset", &self.byte_offset());
        ds.field("packet_header", &self.packet_header());
        ds.field("elements_count", &self.elements_count());
        ds.field("start_t", &self.start_t());
        ds.field("end_t", &self.end_t());
        ds.finish()
    }
}
pub enum FileDataTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FileDataTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileDataTable<'a> {
    type Inner = FileDataTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FileDataTable<'a> {
    pub const VT_FILE_DATA_DEFINITIONS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileDataTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FileDataTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<FileDataTable<'bldr>> {
        let mut builder = FileDataTableBuilder::new(_fbb);
        if let Some(x) = args.file_data_definitions {
            builder.add_file_data_definitions(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn file_data_definitions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileDataDefinition<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileDataDefinition>>,
            >>(FileDataTable::VT_FILE_DATA_DEFINITIONS, None)
        }
    }
}

impl flatbuffers::Verifiable for FileDataTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FileDataDefinition>>,
            >>(
                "file_data_definitions",
                Self::VT_FILE_DATA_DEFINITIONS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct FileDataTableArgs<'a> {
    pub file_data_definitions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileDataDefinition<'a>>>,
        >,
    >,
}
impl<'a> Default for FileDataTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileDataTableArgs {
            file_data_definitions: None,
        }
    }
}

pub struct FileDataTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FileDataTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_file_data_definitions(
        &mut self,
        file_data_definitions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<FileDataDefinition<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FileDataTable::VT_FILE_DATA_DEFINITIONS,
            file_data_definitions,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FileDataTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FileDataTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FileDataTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FileDataTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FileDataTable");
        ds.field("file_data_definitions", &self.file_data_definitions());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FileDataTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_data_table_unchecked`.
pub fn root_as_file_data_table(
    buf: &[u8],
) -> Result<FileDataTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<FileDataTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FileDataTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_file_data_table_unchecked`.
pub fn size_prefixed_root_as_file_data_table(
    buf: &[u8],
) -> Result<FileDataTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<FileDataTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FileDataTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_data_table_unchecked`.
pub fn root_as_file_data_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<FileDataTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<FileDataTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FileDataTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_data_table_unchecked`.
pub fn size_prefixed_root_as_file_data_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<FileDataTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<FileDataTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FileDataTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FileDataTable`.
pub unsafe fn root_as_file_data_table_unchecked(buf: &[u8]) -> FileDataTable {
    flatbuffers::root_unchecked::<FileDataTable>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FileDataTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FileDataTable`.
pub unsafe fn size_prefixed_root_as_file_data_table_unchecked(buf: &[u8]) -> FileDataTable {
    flatbuffers::size_prefixed_root_unchecked::<FileDataTable>(buf)
}
pub const FILE_DATA_TABLE_IDENTIFIER: &str = "FTAB";

#[inline]
pub fn file_data_table_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, FILE_DATA_TABLE_IDENTIFIER, false)
}

#[inline]
pub fn file_data_table_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, FILE_DATA_TABLE_IDENTIFIER, true)
}

#[inline]
pub fn finish_file_data_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FileDataTable<'a>>,
) {
    fbb.finish(root, Some(FILE_DATA_TABLE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_file_data_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FileDataTable<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(FILE_DATA_TABLE_IDENTIFIER));
}
